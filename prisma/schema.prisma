generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// USER & AUTH
// ============================================

model User {
  id              String    @id @default(cuid())
  email           String?   @unique
  emailVerified   DateTime?
  passwordHash    String?
  name            String?
  username        String?   @unique
  image           String?
  bio             String?
  walletAddress   String?   @unique
  githubId        String?   @unique
  githubUsername  String?
  
  // Verification & Trust
  isVerified      Boolean   @default(false)
  verifiedAt      DateTime?
  isAdmin         Boolean   @default(false)
  
  // Stats
  totalSales      Int       @default(0)
  totalPurchases  Int       @default(0)
  totalVolume     Decimal   @default(0) @db.Decimal(18, 8)
  rating          Decimal   @default(0) @db.Decimal(3, 2)
  ratingCount     Int       @default(0)
  sellerLevel     Int       @default(1)
  successRate     Decimal   @default(100) @db.Decimal(5, 2)

  // Dispute Stats
  totalDisputes   Int       @default(0)
  disputeCount    Int       @default(0)
  disputesWon     Int       @default(0)
  disputesLost    Int       @default(0)

  // Badges
  isSuperSeller   Boolean   @default(false)
  isSuperBuyer    Boolean   @default(false)
  superSellerAt   DateTime?
  superBuyerAt    DateTime?

  // Auth method (how user signed up)
  authMethod      AuthMethod @default(WALLET)
  privyUserId     String?   @unique  // Privy DID if using Privy
  
  // Referral System
  referralCode       String?   @unique  // Unique code like "alex123" or auto-generated
  referralCodeCustomized Boolean @default(false)  // Can only customize once
  referredBy         String?   // User ID of who referred them
  referralEarnings   Decimal   @default(0) @db.Decimal(18, 8)  // Total earnings from referrals
  
  // Profile Fields (optional)
  displayName     String?
  websiteUrl      String?
  discordHandle   String?
  discordVerified Boolean   @default(false)
  githubVerified  Boolean   @default(false)
  walletVerified  Boolean   @default(false)

  // Twitter/X Integration
  twitterId       String?   @unique
  twitterUsername String?
  twitterVerified Boolean   @default(false)
  twitterLinkedAt DateTime?

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lastActiveAt    DateTime  @default(now())

  // Relations
  listings        Listing[]        @relation("SellerListings")
  bids            Bid[]
  purchases       Transaction[]    @relation("BuyerTransactions")
  sales           Transaction[]    @relation("SellerTransactions")
  reviewsGiven    Review[]         @relation("ReviewAuthor")
  reviewsReceived Review[]         @relation("ReviewSubject")
  watchlist       Watchlist[]
  notifications   Notification[]
  disputes        Dispute[]        @relation("DisputeInitiator")
  disputeResponses Dispute[]       @relation("DisputeRespondent")
  accounts        Account[]
  sessions        Session[]
  offers          Offer[]
  pendingWithdrawals PendingWithdrawal[]

  // Referral Relations
  referralsGiven  Referral[]       @relation("Referrer")
  referralReceived Referral?       @relation("ReferredUser")

  // Messaging Relations
  conversationsAsParticipant1 Conversation[] @relation("ConversationParticipant1")
  conversationsAsParticipant2 Conversation[] @relation("ConversationParticipant2")
  messagesSent    Message[]        @relation("MessageSender")

  // Collaborator Relations (when user is a collaborator on other listings)
  collaborations  ListingCollaborator[]

  // Purchase Partner Relations (when user is a co-buyer on transactions)
  transactionPartners TransactionPartner[]

  // Multi-wallet support
  wallets           UserWallet[]

  // NDA signatures
  ndaSignatures     ListingNDA[]

  // Review reports & responses
  reviewReportsSubmitted ReviewReport[] @relation("ReviewReporter")
  reviewReportsResolved  ReviewReport[] @relation("ReviewReportResolver")
  reviewResponses        ReviewResponse[]

  // Agent API
  apiKeys         ApiKey[]
  webhooks        Webhook[]

  @@index([walletAddress])
  @@index([email])
  @@index([githubUsername])
  @@index([referralCode])
  @@index([twitterUsername])
  @@index([privyUserId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Revoked sessions for immediate invalidation
// Used for logout, security incidents, password changes, etc.
model RevokedSession {
  id        String   @id @default(cuid())
  sessionId String   @unique // The JWT session ID to revoke
  userId    String?  // Optional: which user's session was revoked
  reason    String?  // Optional: why it was revoked (logout, security, etc.)
  revokedAt DateTime @default(now())
  expiresAt DateTime // When this revocation record can be cleaned up

  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
}

// User's linked wallets (supports multiple wallets per account)
model UserWallet {
  id            String     @id @default(cuid())
  userId        String
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  walletAddress String     @unique
  isPrimary     Boolean    @default(false)
  walletType    WalletType @default(EXTERNAL)
  label         String?    // Optional label like "Main", "Trading", etc.
  createdAt     DateTime   @default(now())

  @@index([userId])
  @@index([walletAddress])
}

enum WalletType {
  EXTERNAL       // Connected from Phantom, Solflare, etc.
  PRIVY_EMBEDDED // Created by Privy for email/social login
  PRIVY_EMAIL    // Email login via Privy
  PRIVY_TWITTER  // Twitter login via Privy
}

enum AuthMethod {
  WALLET         // Direct wallet connection
  PRIVY_EMAIL    // Email via Privy
  PRIVY_TWITTER  // Twitter via Privy
  PRIVY_WALLET   // Wallet via Privy
}

// ============================================
// LISTINGS & AUCTIONS
// ============================================

model ListingCollaborator {
  id                String              @id @default(cuid())

  // Listing relation
  listingId         String
  listing           Listing             @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Collaborator identification (wallet is required for payment, userId is optional)
  walletAddress     String              // Required for payment distribution
  userId            String?             // Optional: linked if they're a registered user
  user              User?               @relation(fields: [userId], references: [id])

  // Role & Description
  role              CollaboratorRole    // PARTNER or COLLABORATOR
  roleDescription   CollaboratorRoleDescription @default(OTHER)
  customRoleDescription String?         // Free-form text when roleDescription is OTHER

  // Payment split
  percentage        Decimal             @db.Decimal(5, 2) // Their cut of the sale (e.g., 25.5 for 25.5%)
  // Application enforces 0-100 range

  // Permissions
  canEdit           Boolean             @default(false) // Partners can edit, collaborators cannot

  // Invitation status
  status            CollaboratorStatus  @default(PENDING)
  invitedAt         DateTime            @default(now())
  respondedAt       DateTime?

  // Timestamps
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@unique([listingId, walletAddress]) // Can't add same wallet twice to a listing
  @@index([listingId])
  @@index([walletAddress])
  @@index([userId])
  @@index([status])
}

model Listing {
  id                String        @id @default(cuid())
  slug              String        @unique
  
  // Basic Info
  title             String
  tagline           String?
  description       String        @db.Text
  categories        Category[]
  blockchain        Blockchain?   // Optional: for on-chain/crypto projects
  tags              String[]
  
  // Tech Stack
  techStack         String[]
  frameworks        String[]
  languages         String[]
  
  // Assets Included
  githubRepo        String?
  githubRepoId      String?
  hasDomain         Boolean       @default(false)
  domain            String?
  hasDatabase       Boolean       @default(false)
  databaseType      String?
  hasHosting        Boolean       @default(false)
  hostingProvider   String?
  hasSocialAccounts Boolean       @default(false)
  socialAccounts    Json?
  hasApiKeys        Boolean       @default(false)
  hasDesignFiles    Boolean       @default(false)
  hasDocumentation  Boolean       @default(false)
  hasVercel         Boolean       @default(false)
  vercelProjectUrl  String?
  vercelTeamSlug    String?
  additionalAssets  String?       @db.Text

  // NDA Settings
  requiresNDA       Boolean       @default(false)
  ndaTerms          String?       @db.Text  // Custom terms or null for default

  // Agreement Settings (seller offers upfront; buyer can request during transfer if not offered)
  offersAPA             Boolean   @default(false)  // Seller offers Asset Purchase Agreement
  offersNonCompete      Boolean   @default(false)  // Seller offers Non-Compete Agreement
  nonCompeteDurationYears Int?                     // 1, 2, or 3 years (if offersNonCompete)
  
  // Media
  thumbnailUrl      String?
  screenshotUrls    String[]
  demoUrl           String?
  videoUrl          String?

  // Required Buyer Information (seller specifies what they need from buyers)
  // JSON structure: { github?: { required: true, description: "..." }, domain?: {...}, ... }
  requiredBuyerInfo Json?
  buyerInfoLocked   Boolean   @default(false)  // Locked once first purchase is made
  
  // Metrics (if deployed)
  monthlyUsers      Int?
  monthlyRevenue    Decimal?  @db.Decimal(18, 8)
  githubStars       Int?
  
  // Auction Settings
  listingType       ListingType   @default(AUCTION)
  startingPrice     Decimal   @db.Decimal(18, 8)
  buyNowPrice       Decimal?  @db.Decimal(18, 8)
  buyNowEnabled     Boolean       @default(false)
  currency          Currency      @default(APP)
  
  // Timing
  startTime         DateTime      @default(now())
  endTime           DateTime
  
  // Status
  status            ListingStatus @default(DRAFT)
  featured          Boolean       @default(false)
  featuredUntil     DateTime?
  
  // On-chain
  onChainId         String?       @unique
  escrowAddress     String?
  nftMint           String?

  // Reservation (when seller accepts offer or reserves for a specific buyer)
  reservedBuyerWallet String?     // Wallet address the listing is reserved for (may not be a user yet)
  reservedBuyerId     String?     // User ID if the reserved wallet belongs to a registered user
  reservedAt          DateTime?   // When the reservation was made

  // Relations
  sellerId          String
  seller            User          @relation("SellerListings", fields: [sellerId], references: [id])
  collaborators     ListingCollaborator[]
  bids              Bid[]
  offers            Offer[]
  pendingWithdrawals PendingWithdrawal[]
  transaction       Transaction?
  watchlist         Watchlist[]
  ndaSignatures     ListingNDA[]
  similarities      ListingSimilarity[] @relation("ListingSimilarities")
  similarTo         ListingSimilarity[] @relation("SimilarListings")
  
  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  publishedAt       DateTime?

  @@index([sellerId])
  @@index([status])
  @@index([categories])
  @@index([endTime])
  @@index([featured])
  @@index([reservedBuyerWallet])
  @@index([reservedBuyerId])
}

model Bid {
  id            String    @id @default(cuid())
  amount        Decimal   @db.Decimal(18, 8)
  currency      Currency  @default(SOL)
  maxBid        Decimal?  @db.Decimal(18, 8)    // For auto-bidding
  
  // On-chain
  onChainTx     String?
  
  // Status
  isWinning     Boolean   @default(false)
  isOutbid      Boolean   @default(false)
  
  // Relations
  listingId     String
  listing       Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  bidderId      String
  bidder        User      @relation(fields: [bidderId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt     DateTime  @default(now())

  @@index([listingId])
  @@index([bidderId])
  @@index([isWinning])
  @@index([createdAt])
}

// ============================================
// OFFERS & WITHDRAWALS
// ============================================

model Offer {
  id            String      @id @default(cuid())
  amount        Decimal   @db.Decimal(18, 8)
  deadline      DateTime
  currency      Currency    @default(SOL)

  // Status
  status        OfferStatus @default(ACTIVE)

  // On-chain
  onChainId     String?     @unique
  escrowAddress String?

  // Relations
  listingId     String
  listing       Listing     @relation(fields: [listingId], references: [id], onDelete: Cascade)
  buyerId       String
  buyer         User        @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  acceptedAt    DateTime?
  cancelledAt   DateTime?
  expiredAt     DateTime?

  @@index([listingId])
  @@index([buyerId])
  @@index([status])
  @@index([deadline])
  @@index([createdAt])
}

model PendingWithdrawal {
  id            String   @id @default(cuid())
  amount        Decimal  @db.Decimal(18, 8)
  currency      Currency @default(SOL)
  claimed       Boolean  @default(false)

  // On-chain
  onChainId     String?  @unique

  // Relations
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listingId     String
  listing       Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt     DateTime @default(now())
  claimedAt     DateTime?

  @@index([userId])
  @@index([listingId])
  @@index([claimed])
}

// ============================================
// UPLOADS (Asset Transfer)
// ============================================

model Upload {
  id            String     @id @default(cuid())

  // Upload Type
  type          UploadType

  // File/URL Info
  url           String?    // GitHub URL, file URL, etc.
  fileKey       String?    // S3/storage key
  fileName      String?
  fileSize      Int?       // in bytes

  // Metadata (credentials, social accounts, etc.)
  metadata      Json?

  // Verification
  verified      Boolean    @default(false)
  verifiedAt    DateTime?

  // Relations
  transactionId String
  transaction   Transaction @relation(fields: [transactionId], references: [id])

  // Timestamps
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@index([transactionId])
  @@index([type])
  @@index([verified])
}

// ============================================
// TRANSACTIONS & ESCROW
// ============================================

model Transaction {
  id                  String            @id @default(cuid())
  
  // Amount
  salePrice           Decimal           @db.Decimal(18, 8)
  platformFee         Decimal           @db.Decimal(18, 8)
  sellerProceeds      Decimal           @db.Decimal(18, 8)
  currency            Currency          @default(SOL)
  
  // Payment
  paymentMethod       PaymentMethod
  stripePaymentId     String?
  onChainTx           String?
  escrowAddress       String?
  
  // Status
  status              TransactionStatus @default(PENDING)

  // Transfer Checklist
  transferChecklist   Json?

  // Buyer Information Collection (48-hour deadline after purchase)
  buyerProvidedInfo     Json?             // Info submitted by buyer
  buyerInfoDeadline     DateTime?         // 48 hours from purchase
  buyerInfoStatus       BuyerInfoStatus   @default(PENDING)
  buyerInfoSubmittedAt  DateTime?

  // Transfer Methods per asset (tracks native vs fallback)
  // JSON structure: { github: { method: "native"|"fallback", ... }, domain: {...} }
  transferMethods       Json?
  fallbackTransferUsed  Boolean           @default(false)

  // Upload Verification
  sellerConfirmedTransfer Boolean        @default(false)
  uploadsVerified         Boolean        @default(false)
  verificationHash        String?
  verifiedAt              DateTime?

  // NFT
  ownershipNftMint    String?
  
  // Purchase Partners (co-buyers)
  partners              TransactionPartner[]
  partnerDepositDeadline DateTime?       // 30 min from initiation for all partners to deposit
  hasPartners           Boolean          @default(false)

  // Non-compete request (buyer can request at purchase)
  nonCompeteRequested       Boolean       @default(false)
  nonCompeteDurationYears   Int?          // 1, 2, or 3 years
  nonCompeteSigned          Boolean       @default(false)
  nonCompeteSignedAt        DateTime?
  nonCompeteSignature       String?

  // APA (Asset Purchase Agreement)
  apaSigned                 Boolean       @default(false)
  apaSignedAt               DateTime?
  apaSignature              String?

  // Buyer agreement requests (when seller didn't offer)
  buyerRequestedAPA         Boolean       @default(false)
  buyerRequestedNonCompete  Boolean       @default(false)

  // Relations
  listingId           String            @unique
  listing             Listing           @relation(fields: [listingId], references: [id])
  buyerId             String
  buyer               User              @relation("BuyerTransactions", fields: [buyerId], references: [id])
  sellerId            String
  seller              User              @relation("SellerTransactions", fields: [sellerId], references: [id])
  dispute             Dispute?
  reviews             Review[]
  uploads             Upload[]
  agreements          TransactionAgreement[]

  // Timestamps
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  paidAt              DateTime?
  transferStartedAt   DateTime?
  transferCompletedAt DateTime?
  releasedAt          DateTime?
  refundedAt          DateTime?
  refundReason        String?

  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([createdAt])
}

// ============================================
// PURCHASE PARTNERS (Co-buyers)
// ============================================

model TransactionPartner {
  id                String                @id @default(cuid())

  // Transaction relation
  transactionId     String
  transaction       Transaction           @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Partner identification (wallet required for payment, userId optional)
  walletAddress     String                // Required for deposits/refunds
  userId            String?               // Optional: linked if registered user
  user              User?                 @relation(fields: [userId], references: [id])

  // Percentage & Amount
  percentage        Decimal               @db.Decimal(5, 2) // Their share (e.g., 40 for 40%)
  depositAmount     Decimal               @db.Decimal(18, 8) // Amount they need to deposit (calculated)

  // Lead buyer status
  isLead            Boolean               @default(false)

  // Deposit status
  depositStatus     PartnerDepositStatus  @default(PENDING)
  depositedAt       DateTime?
  depositTxHash     String?               // On-chain transaction hash

  // Transfer confirmation (for majority vote)
  hasConfirmedTransfer Boolean            @default(false)
  confirmedAt       DateTime?

  // Timestamps
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt

  @@unique([transactionId, walletAddress]) // Can't add same wallet twice
  @@index([transactionId])
  @@index([walletAddress])
  @@index([userId])
  @@index([depositStatus])
}

enum PartnerDepositStatus {
  PENDING     // Hasn't deposited yet
  DEPOSITED   // Successfully deposited their share
  REFUNDED    // Refunded due to timeout or cancellation
}

// ============================================
// DISPUTES
// ============================================

model Dispute {
  id                String        @id @default(cuid())
  
  // Reason
  reason            DisputeReason
  description       String        @db.Text
  
  // Evidence
  initiatorEvidence Json?
  respondentEvidence Json?
  
  // Status
  status            DisputeStatus @default(OPEN)
  resolution        DisputeResolution?
  resolutionNotes   String?       @db.Text
  
  // Fees
  disputeFee        Decimal       @db.Decimal(18, 8) // 2% fee charged to losing party
  feeCharged        Boolean       @default(false)

  // Relations
  transactionId     String        @unique
  transaction       Transaction   @relation(fields: [transactionId], references: [id])
  initiatorId       String
  initiator         User          @relation("DisputeInitiator", fields: [initiatorId], references: [id])
  respondentId      String
  respondent        User          @relation("DisputeRespondent", fields: [respondentId], references: [id])
  
  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  resolvedAt        DateTime?

  @@index([status])
  @@index([transactionId])
}

// ============================================
// REVIEWS & RATINGS
// ============================================

model Review {
  id            String      @id @default(cuid())

  // Review Type
  type          ReviewType   @default(TRANSACTION)
  role          ReviewerRole @default(BUYER) // Was the author a buyer or seller in the transaction

  // Overall Rating (1-5)
  rating        Int         // Overall rating 1-5
  // Application enforces 1-5 range

  // Multi-Criteria Ratings (1-5, optional)
  communicationRating Int?  // How responsive and clear
  speedRating         Int?  // How fast the process was
  accuracyRating      Int?  // Did listing match description / was info accurate

  // Written Review
  comment       String?     @db.Text

  // Relations - transactionId is optional for messaging-based reviews
  transactionId   String?
  transaction     Transaction? @relation(fields: [transactionId], references: [id])
  conversationId  String?       // For messaging-based reviews
  authorId        String
  author          User        @relation("ReviewAuthor", fields: [authorId], references: [id])
  subjectId       String
  subject         User        @relation("ReviewSubject", fields: [subjectId], references: [id])

  // Moderation
  isVisible       Boolean     @default(true)
  reportedAt      DateTime?
  reportReason    String?

  // Relations
  reports         ReviewReport[]
  response        ReviewResponse?

  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([transactionId, authorId])
  @@unique([conversationId, authorId])
  @@index([subjectId])
  @@index([type])
  @@index([rating])
}

enum ReviewType {
  TRANSACTION   // Review after a completed sale
  MESSAGING     // Review based on messaging interaction
}

enum ReviewerRole {
  BUYER
  SELLER
}

// ============================================
// WATCHLIST & NOTIFICATIONS
// ============================================

model Watchlist {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  data      Json?
  read      Boolean          @default(false)
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

// ============================================
// MESSAGING
// ============================================

model Conversation {
  id            String    @id @default(cuid())

  // Participants
  participant1Id String
  participant1   User      @relation("ConversationParticipant1", fields: [participant1Id], references: [id])
  participant2Id String
  participant2   User      @relation("ConversationParticipant2", fields: [participant2Id], references: [id])

  // Optional: Link to listing (for context)
  listingId     String?

  // Last message preview
  lastMessageAt DateTime?
  lastMessagePreview String?

  // Messages
  messages      Message[]

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([participant1Id, participant2Id])
  @@index([participant1Id])
  @@index([participant2Id])
  @@index([lastMessageAt])
}

model Message {
  id             String       @id @default(cuid())
  content        String       @db.Text

  // Sender
  senderId       String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id])

  // Conversation
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Status
  read           Boolean      @default(false)
  readAt         DateTime?

  // Timestamps
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([read])
  @@index([createdAt])
}

// ============================================
// TOKEN LAUNCHES
// ============================================

model TokenLaunch {
  id              String            @id @default(cuid())
  
  // Token Info
  tokenName       String
  tokenSymbol     String
  tokenMint       String?
  totalSupply     BigInt
  
  // Launch Config
  launchType      TokenLaunchType
  presalePrice    Decimal?  @db.Decimal(18, 8)
  listingPrice    Decimal?  @db.Decimal(18, 8)
  
  // Platform Fee (1% of supply)
  platformTokens  BigInt?
  
  // Status
  status          TokenLaunchStatus @default(PENDING)
  
  // Related Project
  projectId       String
  
  // Timestamps
  createdAt       DateTime          @default(now())
  launchedAt      DateTime?

  @@index([status])
}

// ============================================
// ENUMS
// ============================================

enum Category {
  SAAS
  MOBILE_APP
  WEB_APP
  BROWSER_EXTENSION
  API
  AI_ML
  ECOMMERCE
  MARKETPLACE
  SOCIAL
  PRODUCTIVITY
  DEVELOPER_TOOLS
  FINTECH
  GAMING
  CRYPTO_WEB3
  OTHER
}

enum Blockchain {
  SOLANA
  BASE
  HYPERLIQUID
  ETHEREUM
  BITCOIN
}

enum ListingType {
  AUCTION
  FIXED_PRICE
}

enum ListingStatus {
  DRAFT
  PENDING_COLLABORATORS  // Waiting for all collaborators to accept
  PENDING_REVIEW
  ACTIVE
  RESERVED
  ENDED
  SOLD
  CANCELLED
  EXPIRED
}

enum Currency {
  SOL
  USDC
  USD
  APP
}

enum PaymentMethod {
  SOLANA
  STRIPE
  USDC
}

enum TransactionStatus {
  PENDING
  AWAITING_PARTNER_DEPOSITS  // Waiting for all purchase partners to deposit
  FUNDED                     // Funds deposited, ready for transfer
  PAID
  IN_ESCROW
  TRANSFER_PENDING
  TRANSFER_IN_PROGRESS
  AWAITING_CONFIRMATION
  DISPUTED
  COMPLETED
  REFUNDED
  CANCELLED
}

enum DisputeReason {
  GITHUB_NOT_TRANSFERRED
  DOMAIN_NOT_TRANSFERRED
  CREDENTIALS_NOT_RECEIVED
  CODE_DOESNT_MATCH
  MISSING_ASSETS
  OTHER
}

enum DisputeStatus {
  OPEN
  AWAITING_RESPONSE
  UNDER_REVIEW
  RESOLVED
  ESCALATED
}

enum DisputeResolution {
  FULL_REFUND
  PARTIAL_REFUND
  RELEASE_TO_SELLER
  EXTEND_DEADLINE
}

enum NotificationType {
  // Bid/Auction notifications
  BID_PLACED
  BID_OUTBID
  AUCTION_WON
  AUCTION_LOST
  AUCTION_ENDING_SOON
  AUCTION_EXTENDED          // Notify when auction deadline is extended

  // Transfer notifications
  TRANSFER_STARTED
  TRANSFER_COMPLETED

  // Payment notifications
  PAYMENT_RECEIVED
  PAYMENT_FAILED            // Notify when payment fails
  REFUND_PROCESSED          // Notify when refund is processed
  PAYOUT_INITIATED          // Notify seller when payout is started
  PAYOUT_COMPLETED          // Notify seller when payout completes

  // Sale notifications
  SALE_CANCELLED            // Notify when sale is cancelled

  // Dispute notifications
  DISPUTE_OPENED
  DISPUTE_RESOLVED

  // Review notifications
  REVIEW_RECEIVED

  // Watchlist notifications
  WATCHLIST_ENDING
  WATCHLIST_PRICE_DROP      // Notify when watched listing price drops
  WATCHLIST_NEW_BID         // Notify when someone bids on watched listing
  WATCHLIST_UPDATED         // Notify when watched listing is updated

  // Message notifications
  MESSAGE_RECEIVED

  // Buyer info notifications
  BUYER_INFO_REQUIRED       // Notify buyer to submit required info
  BUYER_INFO_REMINDER       // Reminder at 24h and 6h remaining
  BUYER_INFO_SUBMITTED      // Notify seller that buyer submitted info
  BUYER_INFO_DEADLINE       // Notify both when deadline passes
  FALLBACK_TRANSFER_ACTIVE  // Notify when fallback process starts

  // Listing notifications
  LISTING_CREATED           // Confirm listing is published
  LISTING_RESERVED          // Notify buyer when a listing is reserved for them
  LISTING_APPROVED          // Notify seller when admin approves listing
  LISTING_REJECTED          // Notify seller when admin rejects listing
  LISTING_EXPIRED           // Notify when listing expires
  LISTING_UPDATED           // Notify watchers when listing is updated

  // Offer notifications
  OFFER_RECEIVED            // Notify seller when they receive an offer
  OFFER_ACCEPTED            // Notify buyer when their offer is accepted
  OFFER_REJECTED            // Notify buyer when their offer is rejected
  OFFER_COUNTERED           // Notify buyer when seller counters their offer
  OFFER_EXPIRED             // Notify both when offer expires

  // Collaboration notifications
  COLLABORATION_INVITE      // Notify user when invited to collaborate on a listing
  COLLABORATION_ACCEPTED    // Notify listing owner when collaborator accepts
  COLLABORATION_DECLINED    // Notify listing owner when collaborator declines
  COLLABORATION_REMOVED     // Notify collaborator when removed from listing

  // Purchase partner notifications
  PURCHASE_PARTNER_INVITE           // Notify user when invited to be a purchase partner
  PURCHASE_PARTNER_DEPOSITED        // Notify lead buyer when a partner deposits
  PURCHASE_PARTNER_ALL_READY        // Notify all partners when 100% deposited
  PURCHASE_PARTNER_TIMEOUT          // Notify all partners when deposit window expires
  PURCHASE_PARTNER_LEAD_TRANSFERRED // Notify when lead status transferred

  // Referral notifications
  REFERRAL_EARNED           // Notify referrer when they earn commission

  // Agreement notifications
  AGREEMENT_REQUESTED       // Buyer requested APA or Non-Compete
  AGREEMENT_SIGNED          // Seller signed APA or Non-Compete

  // Account notifications
  VERIFICATION_REQUIRED     // Notify when account verification is needed
  VERIFICATION_COMPLETED    // Notify when account is verified
  ACCOUNT_SUSPENDED         // Notify when account is suspended
  ACCOUNT_REACTIVATED       // Notify when account is reactivated

  // Security notifications
  LOGIN_NEW_DEVICE          // Notify when login from new device
  PASSWORD_CHANGED          // Notify when password is changed
  SECURITY_ALERT            // Notify on suspicious activity

  SYSTEM
}

enum BuyerInfoStatus {
  PENDING          // Buyer hasn't submitted info yet
  PROVIDED         // Buyer has submitted required info
  DEADLINE_PASSED  // 48-hour deadline passed without info
}

enum TokenLaunchType {
  FAIR_LAUNCH
  PRESALE
}

enum TokenLaunchStatus {
  PENDING
  LAUNCHING
  LIVE
  COMPLETED
  FAILED
}

// ============================================
// REFERRAL SYSTEM
// ============================================

model Referral {
  id              String    @id @default(cuid())

  // Who referred whom
  referrerId      String
  referrer        User      @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)

  referredUserId  String    @unique
  referredUser    User      @relation("ReferredUser", fields: [referredUserId], references: [id])

  // Tracking
  status          ReferralStatus @default(PENDING)

  // First transaction bonus tracking (only paid once)
  firstTransactionPaid Boolean @default(false)

  // Earnings from this referral
  totalEarnings   Decimal   @default(0) @db.Decimal(18, 8)

  // Timestamps
  createdAt       DateTime  @default(now())
  convertedAt     DateTime? // When referredUser made first sale/purchase

  // Individual earnings records
  earnings        ReferralEarning[]

  @@index([referrerId])
  @@index([referredUserId])
}

model ReferralEarning {
  id              String    @id @default(cuid())
  
  referralId      String
  referral        Referral  @relation(fields: [referralId], references: [id], onDelete: Cascade)
  
  // What transaction generated this earning
  transactionId   String
  
  // Amounts
  saleAmount      Decimal   @db.Decimal(18, 8) // Total sale amount
  commissionRate  Decimal   @db.Decimal(5, 4) // e.g., 0.02 for 2%
  earnedAmount    Decimal   @db.Decimal(18, 8) // saleAmount * commissionRate
  
  // Status
  status          EarningStatus @default(PENDING)
  paidAt          DateTime?
  
  createdAt       DateTime  @default(now())
  
  @@index([referralId])
  @@index([transactionId])
}

enum ReferralStatus {
  PENDING     // Invited but not signed up
  REGISTERED  // Signed up but no transaction
  ACTIVE      // Has completed at least one transaction
}

enum EarningStatus {
  PENDING     // Waiting for transaction to complete
  AVAILABLE   // Ready to withdraw
  PAID        // Withdrawn/paid out
}

enum OfferStatus {
  ACTIVE
  ACCEPTED
  CANCELLED
  EXPIRED
}

enum UploadType {
  GITHUB
  FILE
  CREDENTIALS
  DOCUMENTATION
  DOMAIN
  DATABASE
  HOSTING
  SOCIAL_ACCOUNT
  API_KEYS
  DESIGN_FILES
  VERCEL
}

// ============================================
// NDA (Non-Disclosure Agreements)
// ============================================

model ListingNDA {
  id              String    @id @default(cuid())

  // Listing relation
  listingId       String
  listing         Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Signer info
  signerId        String
  signer          User      @relation(fields: [signerId], references: [id])
  signerWallet    String    // Wallet that signed

  // Signature proof
  signature       String    // Wallet signature
  signedMessage   String    @db.Text // The exact message that was signed

  // Terms version (in case we update terms)
  termsVersion    String    @default("1.0")

  // Timestamps
  signedAt        DateTime  @default(now())

  @@unique([listingId, signerId]) // One NDA per user per listing
  @@index([listingId])
  @@index([signerId])
}

// ============================================
// AGREEMENTS (APA, Non-Compete)
// ============================================

model TransactionAgreement {
  id              String          @id @default(cuid())

  // Transaction relation
  transactionId   String
  transaction     Transaction     @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Agreement type
  type            AgreementType

  // Terms content (markdown)
  termsContent    String          @db.Text
  termsVersion    String          @default("1.0")

  // For non-compete: duration in years
  nonCompeteDurationYears Int?

  // Seller signature
  sellerSigned    Boolean         @default(false)
  sellerSignature String?
  sellerSignedAt  DateTime?

  // Buyer signature
  buyerSigned     Boolean         @default(false)
  buyerSignature  String?
  buyerSignedAt   DateTime?

  // Status
  status          AgreementStatus @default(PENDING)

  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@unique([transactionId, type]) // One of each type per transaction
  @@index([transactionId])
  @@index([type])
  @@index([status])
}

enum AgreementType {
  ASSET_PURCHASE    // APA - standard for all transactions
  NON_COMPETE       // Optional non-compete
}

enum AgreementStatus {
  PENDING           // Waiting for signatures
  SELLER_SIGNED     // Seller signed, waiting for buyer
  BUYER_SIGNED      // Buyer signed, waiting for seller
  COMPLETED         // Both signed
  DECLINED          // One party declined
}

// ============================================
// SIMILAR LISTING DETECTION
// ============================================

model ListingSimilarity {
  id              String    @id @default(cuid())

  // The listing being analyzed
  listingId       String
  listing         Listing   @relation("ListingSimilarities", fields: [listingId], references: [id], onDelete: Cascade)

  // The similar listing found
  similarListingId String
  similarListing  Listing   @relation("SimilarListings", fields: [similarListingId], references: [id], onDelete: Cascade)

  // Similarity scores (0-100)
  titleSimilarity       Decimal @default(0) @db.Decimal(5, 2)
  descriptionSimilarity Decimal @default(0) @db.Decimal(5, 2)
  screenshotSimilarity  Decimal @default(0) @db.Decimal(5, 2)
  overallSimilarity     Decimal @default(0) @db.Decimal(5, 2)

  // Flags
  flagType        SimilarityFlagType @default(INFO)

  // Analysis metadata
  analyzedAt      DateTime  @default(now())

  @@unique([listingId, similarListingId])
  @@index([listingId])
  @@index([similarListingId])
  @@index([overallSimilarity])
  @@index([flagType])
}

enum SimilarityFlagType {
  INFO        // <50% - no display
  SOFT        // 50-89% - visible to buyers
  HARD        // 90%+ - blocks listing pending review
}

// ============================================
// REVIEW REPORTS & RESPONSES
// ============================================

model ReviewReport {
  id              String    @id @default(cuid())

  // Review being reported
  reviewId        String
  review          Review    @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  // Reporter
  reporterId      String
  reporter        User      @relation("ReviewReporter", fields: [reporterId], references: [id])

  // Report details
  reason          ReviewReportReason
  description     String?   @db.Text

  // Admin resolution
  status          ReportStatus @default(PENDING)
  resolvedById    String?
  resolvedBy      User?     @relation("ReviewReportResolver", fields: [resolvedById], references: [id])
  resolution      String?   @db.Text

  // Timestamps
  createdAt       DateTime  @default(now())
  resolvedAt      DateTime?

  @@unique([reviewId, reporterId]) // One report per user per review
  @@index([reviewId])
  @@index([status])
}

model ReviewResponse {
  id              String    @id @default(cuid())

  // Review being responded to
  reviewId        String    @unique
  review          Review    @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  // Responder (the subject of the review)
  responderId     String
  responder       User      @relation(fields: [responderId], references: [id])

  // Response content
  content         String    @db.Text

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([reviewId])
  @@index([responderId])
}

enum ReviewReportReason {
  SPAM
  HARASSMENT
  FALSE_INFORMATION
  INAPPROPRIATE_CONTENT
  OFF_TOPIC
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED_REMOVED    // Review was hidden
  RESOLVED_KEPT       // Review was kept (report dismissed)
}

// ============================================
// COLLABORATOR ENUMS
// ============================================

enum CollaboratorRole {
  PARTNER       // Co-founders, core developers - can edit listing
  COLLABORATOR  // Supporting contributors - cannot edit listing
}

enum CollaboratorStatus {
  PENDING   // Awaiting response to invitation
  ACCEPTED  // Accepted the collaboration
  DECLINED  // Declined the invitation
}

enum CollaboratorRoleDescription {
  // Partner roles
  CO_FOUNDER
  DEVELOPER
  TECHNICAL_LEAD
  CTO
  // Collaborator roles
  DESIGNER
  MARKETING
  VIDEO_EDITOR
  CONSULTANT
  ADVISOR
  BRANDING
  COPYWRITER
  COMMUNITY_MANAGER
  // Generic
  OTHER
}

// ============================================
// AGENT API (API Keys & Webhooks)
// ============================================

model ApiKey {
  id            String    @id @default(cuid())

  // Owner
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Key details
  name          String    // "My Trading Bot", "Analytics Dashboard"
  keyHash       String    @unique // Hashed key (we never store plaintext)
  keyPrefix     String    // First 8 chars for identification: "ak_live_7xKX..."

  // Permissions
  permissions   ApiKeyPermission[] @default([READ, WRITE])

  // Rate limiting
  rateLimit     Int       @default(100) // Requests per minute

  // Usage tracking
  lastUsedAt    DateTime?
  totalRequests Int       @default(0)

  // Status
  isActive      Boolean   @default(true)
  expiresAt     DateTime?

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([keyHash])
  @@index([keyPrefix])
}

enum ApiKeyPermission {
  READ        // Read listings, bids, user profile
  WRITE       // Create listings, place bids, make offers
  TRANSACTION // Execute purchases, sign agreements
  ADMIN       // Manage API keys, webhooks
}

model Webhook {
  id            String    @id @default(cuid())

  // Owner
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Webhook config
  name          String    // "My Bot Notifications"
  url           String    // https://mybot.com/webhook
  secret        String    // HMAC secret for signature verification

  // Events to subscribe to
  events        WebhookEventType[]

  // Status
  isActive      Boolean   @default(true)

  // Delivery stats
  totalDeliveries    Int  @default(0)
  successfulDeliveries Int @default(0)
  failedDeliveries   Int  @default(0)
  lastDeliveryAt     DateTime?
  lastDeliveryStatus WebhookDeliveryStatus?

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Related events
  deliveries    WebhookDelivery[]

  @@index([userId])
  @@index([isActive])
}

model WebhookDelivery {
  id            String    @id @default(cuid())

  // Webhook
  webhookId     String
  webhook       Webhook   @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  // Event details
  eventType     WebhookEventType
  payload       Json      // The event payload sent

  // Delivery status
  status        WebhookDeliveryStatus @default(PENDING)
  attempts      Int       @default(0)
  maxAttempts   Int       @default(3)

  // Response info
  responseStatus Int?     // HTTP status code
  responseBody  String?   @db.Text
  errorMessage  String?

  // Timestamps
  createdAt     DateTime  @default(now())
  deliveredAt   DateTime?
  nextRetryAt   DateTime?

  @@index([webhookId])
  @@index([status])
  @@index([eventType])
  @@index([nextRetryAt])
}

enum WebhookEventType {
  // Listings
  LISTING_CREATED
  LISTING_UPDATED
  LISTING_ENDED
  LISTING_ENDING_SOON

  // Bids
  BID_PLACED
  BID_OUTBID
  BID_WON

  // Transactions
  TRANSACTION_INITIATED
  TRANSACTION_COMPLETED
  TRANSACTION_CANCELLED

  // Agreements
  AGREEMENT_REQUESTED
  AGREEMENT_SIGNED

  // Offers
  OFFER_RECEIVED
  OFFER_ACCEPTED
  OFFER_REJECTED
  OFFER_COUNTERED

  // Messages
  MESSAGE_RECEIVED

  // Watchlist
  WATCHLIST_LISTING_UPDATED
  WATCHLIST_LISTING_ENDING_SOON
}

enum WebhookDeliveryStatus {
  PENDING
  SUCCESS
  FAILED
  RETRYING
}
